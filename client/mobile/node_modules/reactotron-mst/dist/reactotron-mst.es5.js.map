{"version":3,"file":"reactotron-mst.es5.js","sources":["../src/reactotron-mst.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\n// --- Wall of imports ---------------------------------\nimport {\n  addMiddleware,\n  applyAction,\n  applySnapshot,\n  getPath,\n  getSnapshot,\n  getType,\n  isAlive,\n  isProtected,\n  isRoot,\n  onSnapshot,\n} from \"mobx-state-tree\"\nimport type {\n  IStateTreeNode,\n  IType,\n  IMiddlewareEvent,\n  ISerializedActionCall,\n} from \"mobx-state-tree\"\nimport type { Command } from \"reactotron-core-contract\"\nimport {\n  ReactotronCore,\n  Plugin,\n  assertHasStateResponsePlugin,\n  InferFeatures,\n  StateResponsePlugin,\n} from \"reactotron-core-client\"\n\nimport {\n  always,\n  concat,\n  endsWith,\n  filter,\n  flatten,\n  has,\n  identity,\n  is,\n  isEmpty,\n  isNil,\n  keys,\n  map,\n  path,\n  pipe,\n  replace,\n  reject,\n  slice,\n  sortBy,\n  split,\n  uniq,\n  when,\n} from \"ramda\"\n\n// --- Helpers ---------------------------------\n\nconst dotPath = (fullPath: string, o: Record<string, any>) => path(split(\".\", fullPath), o)\nconst isNilOrEmpty = (value: any) => isNil(value) || isEmpty(value)\nconst isReactNativeEvent = (value: any) =>\n  typeof value !== \"undefined\" &&\n  value !== null &&\n  has(\"nativeEvent\", value) &&\n  has(\"target\", value) &&\n  has(\"type\", value)\n\n/**\n * Sadly, this protects calls from endless stack traces.  We have to filter\n * out some things that are known circular troublemakers.\n *\n * @param args A call's args.\n */\nconst convertUnsafeArguments = (args: any) => {\n  const theseArgs = Array.isArray(args) ? args : [args]\n  return theseArgs.map((arg: any) => {\n    if (isReactNativeEvent(arg)) {\n      return \"ReactNativeEvent\"\n    }\n    return arg\n  })\n}\n\nconst isSerializedActionCall = (value: unknown): value is ISerializedActionCall => {\n  return (\n    typeof value === \"object\" &&\n    \"name\" in value &&\n    typeof value.name === \"string\" &&\n    (\"path\" in value ? typeof value.path === \"string\" : true) &&\n    (\"args\" in value ? Array.isArray(value.args) : true)\n  )\n}\n\nconst isSerializedActionCallArray = (value: unknown): value is ISerializedActionCall[] =>\n  Array.isArray(value) && value.every(isSerializedActionCall)\n\n// --- Interfaces ---------------------------------\n\ninterface TrackedNode {\n  /**\n   * The node we are tracking.\n   */\n  node: IStateTreeNode\n\n  /**\n   * The mst model type\n   */\n  modelType: IType<any, any>\n}\n\ninterface NodeTracker {\n  [name: string]: TrackedNode\n}\n\nexport type MstPluginFilter = (event: IMiddlewareEvent) => boolean\n\nexport interface MstPluginOptions {\n  /**\n   * Fine-grain control over what gets sent to the Reactotron app.\n   */\n  filter?: MstPluginFilter\n  /**\n   * When requesting keys, values, or subscribing, configures whether\n   * we talk to the live state object (great for `volatile` state) or the\n   * snapshot.  Defaults to `live`.\n   */\n  queryMode?: \"live\" | \"snapshot\"\n}\n\n// --- The Reactotron Plugin ---------------------------------\n\n/**\n * A factory function for creating the plugin.\n *\n * @param opts Plugin options.\n */\nexport function mst(opts: MstPluginOptions = {}) {\n  /**\n   * The mobx-state-tree Reactotron plugin.\n   *\n   * @param reactotron The reactotron instance we're attaching to.\n   */\n  function plugin<Client extends ReactotronCore = ReactotronCore>(reactotron: Client) {\n    // make sure have loaded the StateResponsePlugin\n    assertHasStateResponsePlugin(reactotron)\n    const client = reactotron as Client & InferFeatures<Client, StateResponsePlugin>\n\n    // --- Plugin-scoped variables ---------------------------------\n\n    // the stores we're tracking\n    const trackedNodes: NodeTracker = {}\n\n    // are we in the middle of restoring?  this will prevent\n    // extra @APPLY_SNAPSHOT signals from being sent\n    let restoring = false\n\n    // a list of subscriptions the client is subscribing to\n    let subscriptions: string[] = []\n\n    const mstFilter = opts.filter ? opts.filter : () => true\n\n    // --- Connecting MST to Reactotron ---------------------------------\n\n    /**\n     * The entry point for integrating a mobx-state-tree node with Reactotron. Currently\n     * one 1 root node is supported.\n     *\n     * @param node The mobx-state-tree node to track\n     * @param nodeName The name to call it if we have more than 1.\n     */\n    function trackMstNode(node: IStateTreeNode, nodeName = \"default\") {\n      // sanity\n      if (!node) {\n        return { kind: \"required\" } as const\n      }\n\n      // prevent double tracking\n      if (trackedNodes[nodeName]) {\n        return { kind: \"already-tracking\" } as const\n      }\n\n      try {\n        // grab the mst model type\n        const modelType = getType(node)\n\n        // we only want types\n        if (modelType.isType) {\n          try {\n            attachReactotronToMstNode(node)\n            // track this\n            trackedNodes[nodeName] = { node, modelType }\n            return { kind: \"ok\" } as const\n          } catch (e) {\n            return {\n              kind: \"tracking-error\",\n              message:\n                e instanceof Error\n                  ? e.message\n                  : \"Unknown error - tracking error did not have message\",\n            } as const\n          }\n        } else {\n          return { kind: \"invalid-node\" } as const\n        }\n      } catch (e) {\n        return { kind: \"invalid-node\" } as const\n      }\n    }\n\n    /**\n     * Connects a mst tree node to Reactotron.\n     *\n     * @param node The node we want to track.\n     * @param nodeName What to call this node.\n     */\n    function attachReactotronToMstNode(node: IStateTreeNode, nodeName?: string) {\n      // whenever the snapshot changes, send subscriptions\n      onSnapshot(node, sendSubscriptions)\n\n      /**\n       * Make some middleware that allows us to track actions.\n       */\n      addMiddleware(node, (call, next) => {\n        // only actions for now\n        const skip = call.type !== \"action\"\n\n        // skip this middleware?\n        if (skip) {\n          return next(call)\n        }\n\n        // userland opt-out\n        const shouldSend = mstFilter(call)\n        if (!shouldSend) {\n          return next(call)\n        }\n\n        // grab the arguments\n        const args = convertUnsafeArguments(call.args)\n        const path = getPath(call.context)\n\n        // action related data\n        const action = { args: args, name: call.name, path }\n\n        // mst internal data\n        const mstPayload = {\n          id: call.id,\n          parentId: call.parentId,\n          rootId: call.rootId,\n          type: call.type,\n          modelType: getType(node),\n          alive: isAlive(node),\n          root: isRoot(node),\n          protected: isProtected(node),\n        }\n\n        // start a timer\n        const elapsed = reactotron.startTimer()\n\n        // chain off to the next middleware\n        const result = next(call)\n\n        // measure the speed\n        const ms = elapsed()\n\n        // add nice display name\n        const displayPath = replace(/^\\./, \"\", replace(/\\//g, \".\", path))\n        let name = replace(/^\\./, \"\", `${nodeName ?? \"\"}${displayPath}.${call.name}()`)\n        name = replace(\"/\", \".\", name)\n        // fire this off to reactotron\n        if (!restoring) {\n          reactotron.send(\"state.action.complete\", {\n            name,\n            action,\n            mst: mstPayload,\n            ms,\n          })\n        }\n\n        // return the result of the next middleware\n        return result\n      })\n    }\n\n    // --- Reactotron Hooks ---------------------------------\n\n    /**\n     * A backup of state has been requested. Lets serialize the current\n     * state and send it up to the app.\n     *\n     * @param command A reactotron command.\n     */\n    function backup(command: Command<\"state.backup.request\">) {\n      const trackedNode =\n        trackedNodes[\n          \"mstNodeName\" in command && typeof command.mstNodeName === \"string\"\n            ? command.mstNodeName\n            : \"default\"\n        ]\n      if (trackedNode && trackedNode.node) {\n        const state = getSnapshot<IStateTreeNode>(trackedNode.node)\n        reactotron.send(\"state.backup.response\", { state })\n      }\n    }\n\n    /**\n     * Update the current state with one that was sent to us by the\n     * Reactotron app.\n     *\n     * @param command A reactotron command.\n     */\n    function restore(command: Command<\"state.restore.request\">) {\n      const trackedNode =\n        trackedNodes[\n          \"mstNodeName\" in command && typeof command.mstNodeName === \"string\"\n            ? command.mstNodeName\n            : \"default\"\n        ]\n      const state = command && command.payload && command.payload.state\n      if (trackedNode && trackedNode.node) {\n        const { node } = trackedNode\n        restoring = true\n        applySnapshot(node, state)\n        restoring = false\n      }\n    }\n\n    /**\n     * Applies an action to the mst node which was sent from the Reactotron\n     * app. It can be a replayed action we emitted earlier, or one the user\n     * has typed in manually.\n     *\n     * @param command A reactotron command.\n     */\n    function dispatchAction(command: Command<\"state.action.dispatch\">) {\n      const trackedNode =\n        trackedNodes[\n          \"mstNodeName\" in command && typeof command.mstNodeName === \"string\"\n            ? command.mstNodeName\n            : \"default\"\n        ]\n      const action = command && command.payload && command.payload.action\n      const isValidAction = isSerializedActionCall(action) || isSerializedActionCallArray(action)\n      if (trackedNode && trackedNode.node && action && isValidAction) {\n        const { node } = trackedNode\n        try {\n          applyAction(node, action)\n        } catch {\n          // TODO: should we return a message?\n        }\n      }\n    }\n\n    /**\n     * Subscribes to some paths in state. Allows the user to track a subset of\n     * data within the state that will be sent to them every time it changes.\n     *\n     * @param command The command received from the reactotron app.\n     */\n    function subscribe(command: Command<\"state.values.subscribe\">) {\n      const trackedNode =\n        trackedNodes[\n          \"mstNodeName\" in command && typeof command.mstNodeName === \"string\"\n            ? command.mstNodeName\n            : \"default\"\n        ]\n      const paths: string[] = (command && command.payload && command.payload.paths) || []\n\n      if (paths) {\n        subscriptions = uniq(flatten(paths))\n      }\n\n      if (trackedNode && trackedNode.node) {\n        const state =\n          opts.queryMode === \"snapshot\" ? getSnapshot(trackedNode.node) : trackedNode.node\n        sendSubscriptions(state)\n      }\n    }\n\n    /**\n     * Given a path somewhere within the tree, list the keys found if it is an object.\n     *\n     * @param command The command received from the reactotron app.\n     */\n    function requestKeys(command: Command<\"state.keys.request\">) {\n      const trackedNode =\n        trackedNodes[\n          \"mstNodeName\" in command && typeof command.mstNodeName === \"string\"\n            ? command.mstNodeName\n            : \"default\"\n        ]\n      const atPath = command?.payload?.path\n      if (trackedNode && trackedNode.node) {\n        const state = getSnapshot<IStateTreeNode>(trackedNode.node)\n        if (isNilOrEmpty(atPath)) {\n          client.stateKeysResponse(null, keys(state))\n        } else {\n          const keyList = keys(dotPath(atPath, state))\n          client.stateKeysResponse(atPath, keyList)\n        }\n      }\n    }\n\n    /**\n     * Gets the current value located at the path within the state tree.\n     *\n     * @param command The command received from the reactotron app.\n     */\n    function requestValues(command: Command<\"state.values.request\">) {\n      const trackedNode =\n        trackedNodes[\n          \"mstNodeName\" in command && typeof command.mstNodeName === \"string\"\n            ? command.mstNodeName\n            : \"default\"\n        ]\n      const atPath = command?.payload?.path\n      if (trackedNode && trackedNode.node) {\n        const state = getSnapshot<IStateTreeNode>(trackedNode.node)\n        if (isNilOrEmpty(atPath)) {\n          client.stateValuesResponse(null, state)\n        } else {\n          client.stateValuesResponse(atPath, dotPath(atPath, state))\n        }\n      }\n    }\n\n    /**\n     * Sends all subscribed values to the Reactotron app.\n     *\n     * @param node The tree to grab the state data from\n     */\n    function sendSubscriptions(state: IStateTreeNode) {\n      // this is unreadable\n      const changes = (pipe as any)(\n        map(when(isNil, always(\"\"))) as any,\n        filter(endsWith(\".*\")),\n        map((key: string) => {\n          const keyMinusWildcard = slice(0, -2, key)\n          const value = dotPath(keyMinusWildcard, state)\n          if (is(Object, value) && !isNilOrEmpty(value)) {\n            return pipe(\n              keys,\n              map((key) => `${keyMinusWildcard}.${key}`)\n            )(value || {})\n          }\n          return []\n        }) as any,\n        concat(map(when(isNil, always(\"\")), subscriptions)),\n        flatten,\n        reject(endsWith(\".*\")) as any,\n        uniq as any,\n        sortBy(identity) as any,\n        map((key: string) => ({\n          path: key,\n          value: isNilOrEmpty(key) ? state : dotPath(key, state),\n        }))\n      )(subscriptions)\n\n      client.stateValuesChange(changes)\n    }\n\n    // --- Reactotron Hooks ---------------------------------\n\n    // maps inbound commands to functions to run\n    const COMMAND_MAP = {\n      \"state.backup.request\": backup,\n      \"state.restore.request\": restore,\n      \"state.action.dispatch\": dispatchAction,\n      \"state.values.subscribe\": subscribe,\n      \"state.keys.request\": requestKeys,\n      \"state.values.request\": requestValues,\n    } satisfies { [name: string]: (command: Command) => void }\n\n    /**\n     * Fires when we receive a command from the reactotron app.\n     */\n    function onCommand(command: Command) {\n      // lookup the command and execute\n      const handler = COMMAND_MAP[command && command.type]\n      handler && handler(command)\n    }\n\n    // --- Reactotron plugin interface ---------------------------------\n\n    return {\n      // Fires when we receive a command from the Reactotron app.\n      onCommand,\n\n      // All keys in this object will be attached to the main Reactotron instance\n      // and available to be called directly.\n      features: { trackMstNode },\n    } satisfies Plugin<Client>\n  }\n\n  return plugin\n}\n"],"names":["dotPath","fullPath","o","path","split","isNilOrEmpty","value","isNil","isEmpty","isReactNativeEvent","has","convertUnsafeArguments","args","theseArgs","Array","isArray","map","arg","isSerializedActionCall","_typeof","name","isSerializedActionCallArray","every","mst","opts","arguments","length","reactotron","attachReactotronToMstNode","node","nodeName","onSnapshot","sendSubscriptions","addMiddleware","call","next","skip","type","shouldSend","mstFilter","getPath","context","action","mstPayload","id","parentId","rootId","modelType","getType","alive","isAlive","root","isRoot","isProtected","elapsed","startTimer","result","ms","displayPath","replace","concat","restoring","send","backup","command","trackedNode","trackedNodes","mstNodeName","state","getSnapshot","restore","payload","applySnapshot","dispatchAction","isValidAction","applyAction","_unused","subscribe","paths","subscriptions","uniq","flatten","queryMode","requestKeys","_command$payload","atPath","client","stateKeysResponse","keys","keyList","requestValues","_command$payload2","stateValuesResponse","changes","pipe","when","always","filter","endsWith","key","keyMinusWildcard","slice","is","Object","reject","sortBy","identity","stateValuesChange","assertHasStateResponsePlugin","COMMAND_MAP","onCommand","handler","features","trackMstNode","kind","isType","e","message","Error"],"mappings":"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"}